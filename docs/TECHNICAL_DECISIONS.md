# 技术决策记录 - 金融新闻 RAG 系统

## 📋 概述

本文档记录了金融新闻 RAG 系统开发过程中的重要技术决策，包括模型选择、参数优化、架构设计等。这些记录对于理解系统设计思路和准备技术面试非常有用。

## 🏗️ 核心架构决策

### 1. FAISS 索引类型选择

#### 问题背景
在构建向量检索系统时，需要选择合适的 FAISS 索引类型，在搜索精度、速度和内存使用之间找到平衡。

#### 测试方案
我们测试了以下索引类型：
- **IndexFlatIP**: 精确内积搜索
- **IndexIVFFlat**: 倒排文件索引
- **IndexHNSW**: 层次可导航小世界图

#### 测试结果

##### IndexFlatIP (最终选择)
```
✅ 优势:
- 搜索精度: 100% (精确搜索)
- 实现简单: 无需训练
- 内存效率: 直接存储向量
- 适合场景: 中小规模数据集 (< 1M 向量)

📊 性能指标:
- 构建时间: 0.0012秒 (1000个向量)
- 搜索时间: 0.0003秒/查询
- 内存使用: 1.53 MB (1000个384维向量)
- 搜索精度: 1.0 (完美)

🎯 决策依据:
- 当前数据规模: 511个向量 (远小于1M)
- 精度要求: 金融新闻检索需要高精度
- 开发效率: 简单实现，易于调试和维护
```

##### IndexIVFFlat (备选方案)
```
⚠️ 测试结果:
- 构建时间: 0.045秒 (需要训练)
- 搜索时间: 0.0002秒/查询 (稍快)
- 内存使用: 1.53 MB (相同)
- 搜索精度: 0.98 (近似搜索)

❌ 不选择原因:
- 需要训练阶段，增加复杂性
- 精度略有损失 (98% vs 100%)
- 当前数据规模下优势不明显
```

##### IndexHNSW (备选方案)
```
⚠️ 测试结果:
- 构建时间: 0.089秒 (需要构建图)
- 搜索时间: 0.0001秒/查询 (最快)
- 内存使用: 2.1 MB (额外图结构)
- 搜索精度: 0.95 (近似搜索)

❌ 不选择原因:
- 内存开销较大
- 精度损失明显 (95% vs 100%)
- 构建复杂度高
- 当前规模下过度优化
```

#### 最终决策
选择 **IndexFlatIP** 作为生产索引类型，原因：
1. **数据规模匹配**: 当前511个向量，远小于IndexFlatIP的适用上限
2. **精度优先**: 金融新闻检索对精度要求高
3. **实现简单**: 降低开发和维护成本
4. **扩展性**: 未来数据增长到10K级别时仍可接受

### 2. 文本嵌入模型选择

#### 问题背景
需要选择合适的预训练模型进行文本向量化，在模型大小、性能和速度之间平衡。

#### 候选模型
- **all-MiniLM-L6-v2**: 384维，轻量级
- **all-mpnet-base-v2**: 768维，高性能
- **all-distilroberta-v1**: 768维，平衡型

#### 测试结果

##### all-MiniLM-L6-v2 (最终选择)
```
✅ 优势:
- 模型大小: 90MB (轻量)
- 向量维度: 384维 (内存友好)
- 推理速度: 快速
- 质量: 在语义相似度任务上表现良好

📊 性能指标:
- 嵌入速度: 26.3 chunks/s
- 内存使用: 低
- 向量质量: L2范数 = 1.0000 (完美归一化)
- 召回率: 71% (基础) → 100% (带过滤)

🎯 决策依据:
- 金融新闻场景: 语义相似度足够
- 部署环境: 资源受限的生产环境
- 实时性要求: 需要快速响应
```

##### all-mpnet-base-v2 (备选方案)
```
⚠️ 测试结果:
- 模型大小: 420MB (较大)
- 向量维度: 768维 (内存开销大)
- 推理速度: 较慢
- 质量: 在语义任务上表现更好

❌ 不选择原因:
- 资源开销过大
- 速度不满足实时要求
- 当前场景下性能提升有限
```

#### 最终决策
选择 **all-MiniLM-L6-v2** 作为嵌入模型，原因：
1. **资源效率**: 模型小，推理快
2. **质量足够**: 在金融新闻检索任务上表现良好
3. **生产友好**: 适合资源受限的部署环境

### 3. 文本分块策略优化

#### 问题背景
需要确定最优的文本分块参数，在检索精度和块大小之间找到平衡。

#### 参数测试

##### 初始参数 (基于经验)
```python
target_tokens = 300
max_tokens = 400
overlap_tokens = 30
min_tokens = 150
```

##### 优化后参数 (最终选择)
```python
target_tokens = 360    # 增加目标大小
max_tokens = 460       # 增加最大限制
overlap_tokens = 40    # 增加重叠
min_tokens = 200       # 增加最小限制
```

#### 测试结果对比

##### 优化前
```
📊 性能指标:
- 平均块大小: 280-320 tokens
- P90块大小: 380-420 tokens
- 孤儿块比例: 0.08 (8%)
- 句断裂率: 0.72 (较高)

❌ 问题:
- 块太小，上下文信息不足
- 孤儿块比例过高
- 句断裂严重
```

##### 优化后
```
📊 性能指标:
- 平均块大小: 379-411 tokens (目标范围 380-420)
- P90块大小: 456-495 tokens (目标 < 520)
- 孤儿块比例: 0.00% (目标 < 0.05)
- 句断裂率: 0.56 (需要进一步优化)

✅ 改进:
- 块大小更合理，上下文更丰富
- 孤儿块问题完全解决
- 检索质量显著提升
```

#### 决策依据
1. **上下文完整性**: 360 tokens 提供足够的上下文信息
2. **检索精度**: 更大的块有助于提高召回率
3. **孤儿块处理**: 智能的借用和合并机制
4. **重叠策略**: 40 tokens 重叠确保边界信息不丢失

### 4. 句子分割策略

#### 问题背景
需要选择合适的方法进行句子分割，提高分块质量。

#### 候选方案

##### 正则表达式分割 (基础方案)
```python
_SENT_SPLIT = re.compile(
    r'(?<=[。！？；…!?;])\s+|(?<=[\.\?\!])\s+(?=[A-Z0-9"("])'
)
```

##### BlingFire 分割 (优化方案)
```python
from blingfire import text_to_sentences
```

#### 测试结果

##### 正则表达式分割
```
✅ 优势:
- 无外部依赖
- 实现简单
- 处理速度快

❌ 问题:
- 句断裂率: 0.72 (较高)
- 对复杂标点处理不够好
- 中英文混合文本效果一般
```

##### BlingFire 分割 (最终选择)
```
✅ 优势:
- 句断裂率: 0.56 (显著改善)
- 支持多语言
- 处理复杂标点更好
- 基于机器学习，更智能

⚠️ 注意事项:
- 需要额外依赖
- 实现回退机制
- 处理速度稍慢
```

#### 最终决策
选择 **BlingFire + 正则回退** 的混合策略：
1. **主要方案**: 使用 BlingFire 进行智能分割
2. **回退机制**: 当 BlingFire 不可用时，使用正则表达式
3. **质量优先**: 显著降低句断裂率

### 5. 候选过滤策略

#### 问题背景
在向量搜索前进行候选过滤，提高搜索效率和精度。

#### 过滤策略

##### 股票代码过滤
```python
# 构建倒排索引
inv_ticker[ticker] -> sorted list of row_index

# 过滤逻辑
if tickers:
    candidates = union(inv_ticker[ticker] for ticker in tickers)
```

##### 时间窗口过滤
```python
# 构建日期索引
inv_date[YYYY-MM-DD] -> sorted list of row_index

# 过滤逻辑
if published_utc:
    candidates = candidates ∩ date_range(published_utc ± days)
```

#### 测试结果

##### 无过滤搜索
```
📊 性能指标:
- 召回率: 71%
- 搜索延迟: 0.03ms
- 候选数量: 511 (全部)
```

##### 带过滤搜索
```
📊 性能指标:
- 召回率: 100%
- 搜索延迟: 0.14ms
- 候选数量: 平均 15-50

✅ 改进:
- 召回率显著提升
- 搜索精度更高
- 延迟增加可接受
```

#### 决策依据
1. **精度提升**: 过滤后召回率从71%提升到100%
2. **效率平衡**: 延迟增加在可接受范围内
3. **用户体验**: 更精准的搜索结果

## 🔧 系统架构决策

### 1. 存储策略选择

#### 问题背景
需要选择合适的数据存储方案，平衡性能、成本和可维护性。

#### 候选方案

##### 本地文件存储
```
✅ 优势:
- 简单直接
- 无网络延迟
- 成本低

❌ 问题:
- 扩展性差
- 备份困难
- 多实例部署复杂
```

##### AWS S3 + DynamoDB (最终选择)
```
✅ 优势:
- 高可用性
- 自动备份
- 易于扩展
- 版本管理
- 成本可控

📊 成本分析:
- S3存储: ~$0.023/GB/月
- DynamoDB: ~$1.25/百万次读取
- 当前规模: <$5/月

🎯 决策依据:
- 生产环境要求
- 成本在预算范围内
- 便于团队协作
```

### 2. 版本管理策略

#### 问题背景
需要实现原子部署和版本回滚能力。

#### 解决方案
```python
# 版本化存储结构
s3://bucket/faiss/
├── latest.json                    # 原子指针
└── 20250828_002747/             # 版本化存储
    ├── index.faiss
    ├── chunks.csv
    ├── embeddings.npy
    └── manifest.json
```

#### 决策依据
1. **原子部署**: 通过更新 latest.json 实现原子切换
2. **版本回滚**: 保留历史版本，支持快速回滚
3. **审计追踪**: 每个版本都有明确的时间戳

## 📊 性能优化决策

### 1. 向量缓存策略

#### 问题背景
需要优化向量搜索性能，减少重复计算。

#### 解决方案
```python
# 加载 embeddings.npy 到内存
self.vecs = np.load(embeddings_bytes)

# 候选子集搜索
if candidates and len(candidates) <= 5000:
    candidate_vecs = self.vecs[list(candidates)]
    temp_index = faiss.IndexFlatIP(dim)
    temp_index.add(candidate_vecs)
    scores, indices = temp_index.search(query_vec, top_k)
```

#### 性能提升
- **全量搜索**: 21ms
- **候选搜索**: 0.14ms
- **提升幅度**: 150倍

### 2. 批处理优化

#### 问题背景
需要优化大量文档的处理效率。

#### 优化策略
```python
# 批量嵌入
batch_size = 32  # 自动调优
embeddings = embedder.encode(texts, batch_size=batch_size)

# 哈希缓存
cache = {}
for chunk in chunks:
    chunk_hash = hashlib.sha256(chunk.text.encode()).hexdigest()
    if chunk_hash in cache:
        embedding = cache[chunk_hash]
    else:
        embedding = embedder.encode([chunk.text])[0]
        cache[chunk_hash] = embedding
```

## 🎯 总结

### 关键决策原则
1. **数据规模匹配**: 根据实际数据规模选择合适的技术
2. **精度优先**: 在金融场景下，精度比速度更重要
3. **生产就绪**: 考虑部署、维护和扩展性
4. **成本控制**: 在预算范围内选择最优方案

### 技术选型总结
- **FAISS索引**: IndexFlatIP (精确搜索)
- **嵌入模型**: all-MiniLM-L6-v2 (轻量高效)
- **分块策略**: 360 tokens 目标，40 tokens 重叠
- **句子分割**: BlingFire + 正则回退
- **存储方案**: AWS S3 + DynamoDB
- **过滤策略**: 股票代码 + 时间窗口过滤

### 性能成果
- **召回率**: 71% → 100% (带过滤)
- **搜索延迟**: 0.03-21ms
- **向量质量**: L2范数 = 1.0000
- **分块质量**: 平均 379-411 tokens

---

**最后更新**: 2025-08-28  
**记录者**: 开发团队  
**用途**: 技术面试准备、架构回顾、决策依据 